<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Liut</title>
    <link>https://www.liut.xyz/tags/java/</link>
    <description>Recent content in java on Liut</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Aug 2019 20:27:36 +0800</lastBuildDate>
    
	<atom:link href="https://www.liut.xyz/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>从 Java 类的初始化看待饿汉单例</title>
      <link>https://www.liut.xyz/posts/java/java-%E5%8D%95%E4%BE%8B/</link>
      <pubDate>Thu, 01 Aug 2019 20:27:36 +0800</pubDate>
      
      <guid>https://www.liut.xyz/posts/java/java-%E5%8D%95%E4%BE%8B/</guid>
      <description>先说观点： 在一般情况下， 饿汉式单例也不一定是立即加载的， 没必要特意使用写法复杂并且可能效率不高的懒汉模式。
单例模式 Java中单例 (Singleton) 模式是一种广泛使用的设计模式。单例模式的主要作用是保证在Java程序中，某个类只有一个实例存在。
分类以及常见写法 根据单例的初始化时机， java 单例可分为两大类别， 懒汉式和饿汉式。 （此外， 还有登记式， 不在本文讨论范围内）
饿汉式 饿汉式是在类加载器初始化该单例类时进行实例化。 常见方式如下：
 静态工厂方法式饿汉 public class EagerSingleton { private static final EagerSingleton INSTANCE = new EagerSingleton(); private EagerSingleton() { System.out.println(&amp;#34;EagerSingleTon&amp;#34;); } public static EagerSingleton getINSTANCE() { return INSTANCE; } }  枚举单例 public enum EnumSingleton { INSTANCE; EnumSingleton() { System.out.println(&amp;#34;EnumSingleton&amp;#34;); } }   懒汉式   DCL(双重校验锁定)单例
public class DoubleCheckLockSingleton { private static volatile DoubleCheckLockSingleton instance; private DoubleCheckLockSingleton() { System.</description>
    </item>
    
    <item>
      <title>java的几种对象(PO,VO,DAO,BO,POJO，DTO)解释</title>
      <link>https://www.liut.xyz/posts/java/java%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AF%B9%E8%B1%A1povodaobopojodto%E8%A7%A3%E9%87%8A/</link>
      <pubDate>Sat, 23 Sep 2017 15:15:15 +0800</pubDate>
      
      <guid>https://www.liut.xyz/posts/java/java%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AF%B9%E8%B1%A1povodaobopojodto%E8%A7%A3%E9%87%8A/</guid>
      <description>PO： persistant object持久对象 最形象的理解就是一个PO就是数据库中的一条记录。 好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。
BO： business object业务对象 主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、 关系等等。 我们可以把教育经历对应一个PO，工作经历对应一个PO， 关系对应一个PO。 建立一个对应简历的BO对象处理简历，每个BO包含这些PO。 这样处理业务逻辑时，我们就可以针对BO去处理。
VO ： value object值对象 ViewObject表现层对象 主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。
DTO ： Data Transfer Object数据传输对象 主要用于远程调用等需要大量传输对象的地方。 比如我们一张表有100个字段，那么对应的PO就有100个属性。 但是我们界面上只要显示10个字段， 客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端， 这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO
POJO ： plain ordinary java object 简单java对象 个人感觉POJO是最常见最多变的对象，是一个中间对象，也是我们最常打交道的对象。 一个POJO持久化以后就是PO 直接用它传递、传递过程中就是DTO 直接用来对应表示层就是VO
１．VO是用new关键字创建，由GC回收的。 PO则是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。 ２．VO是值对象，精确点讲它是业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方。 PO则是有状态的，每个属性代表其当前的状态。它是物理数据的对象表示。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。 ３．VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 PO的属性是跟数据库表的字段一一对应的。PO对象需要实现序列化接口。
From: http://www.cnblogs.com/firstdream/archive/2012/04/13/2445582.html</description>
    </item>
    
    <item>
      <title>位运算</title>
      <link>https://www.liut.xyz/posts/java/%E4%BD%8D%E8%BF%90%E7%AE%97/</link>
      <pubDate>Sat, 23 Sep 2017 15:15:15 +0800</pubDate>
      
      <guid>https://www.liut.xyz/posts/java/%E4%BD%8D%E8%BF%90%E7%AE%97/</guid>
      <description>1. 原码反码补码：
计算机存储数据都是以二进制存储
byte 8位 short 16位 int 32位 long 64位
其中 最高位为符号位，0代表正数，1为负数，并且负数以补码的形式存在和参与计算,如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。
关于原码，反码，补码
原码 即正确的值。 反码 正数不变，负数反码 符号位不变，其余取反。 补码 正数不变，负数为反码+1。
负数(-2)原码反码例如：
原码 1000 0010 反码 1111 1101 补码 1111 1110
2. 位移运算
 a &amp;lt;&amp;lt; b 左移运算 二进制形式的a左移b位，b小于总位数，左端舍去，右端补零，正负可能发生变化。 a &amp;gt;&amp;gt; b 右移运算 二进制形式的a右移b位，b小于总位数，右端舍去，左边正数补0，负数补1。 a &amp;gt;&amp;gt;&amp;gt; b 无符号右移运算 二进制形式的a左移b位，b小于总位数，右端舍去，左端补零  3. 与，或，异或，非
&amp;amp; 同1则1 | 同0则0 ^ 相同为零，不同为1 ~ 取反
应用：
 &amp;amp; 取特定位 |某位 置1 ^特定位取反  例如 :</description>
    </item>
    
  </channel>
</rss>