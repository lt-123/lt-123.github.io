@startuml coroutines 类图

note "coroutines 类图" as N1

interface CoroutineScope {
    + coroutineContext: CoroutineContext
}

class GlobalScope << (S,#FF7700) Singleton >> {
    + coroutineContext: CoroutineContext = EmptyCoroutineContext
}

class ContextScope {
    + coroutineContext: CoroutineContext
}

interface CoroutineContext {
    + <E : Element> get(key: Key<E>): E?
    + <R> fold(initial: R, operation: (R, Element) -> R): R
    + plus(context: CoroutineContext)
    + minusKey(key: Key<*>): CoroutineContext
}

interface Element {
    + key: Key<*>
    + <E : Element> get(key: Key<E>): E?
    + fold(initial: R, operation: (R, Element) -> R): R
    + minusKey(key: Key<*>): CoroutineContext
}

interface Job {
    + isActive: Boolean
    + isCompleted: Boolean
    + isCancelled: Boolean
    
    + children: Sequence<Job>

    + start(): Boolean
    + cancel(): Unit
    + suspend fun join()

    + ... ()
}

abstract CoroutineDispatcher {
    + dispatch(context: CoroutineContext, block: Runnable)
    + ...()
}

abstract MainCoroutineDispatcher
note bottom: Dispatchers.Main UI 线程执行器 由平台具体实现

abstract Unconfined << (S,#FF7700) Singleton >> 
note bottom: Dispatchers.Unconfined

abstract ExecutorCoroutineDispatcher

class LimitingDispatcher
note bottom: Dispatchers.IO

class DefaultScheduler
note bottom: Dispatchers.Default
class CommonPool << (S,#FF7700) Singleton >> 
note bottom: Dispatchers.Default



CoroutineScope o-- CoroutineContext : 聚合


CoroutineScope <|-- GlobalScope : 泛化
CoroutineScope <|-- ContextScope : 泛化

CoroutineContext <|.. Element : 继承

Element <|.. Job : 继承
Element <|-- CoroutineDispatcher : 泛化

CoroutineDispatcher <|.. MainCoroutineDispatcher : 继承
CoroutineDispatcher <|.. Unconfined : 继承
CoroutineDispatcher <|.. ExecutorCoroutineDispatcher : 继承
ExecutorCoroutineDispatcher <|.. LimitingDispatcher : 继承
ExecutorCoroutineDispatcher <|.. DefaultScheduler : 继承
ExecutorCoroutineDispatcher <|.. CommonPool : 继承

@enduml
